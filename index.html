<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>FLIP // FALL</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
  body {
    margin: 0;
    background: #000;
    overflow: hidden;
    touch-action: manipulation;
  }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
// =====================================================
// CANVAS
// =====================================================
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

// =====================================================
// AUDIO
// =====================================================
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioCtx();

let musicBuffer = null;
let musicSource = null;
let musicGain = audioCtx.createGain();
musicGain.gain.value = 0.25;
musicGain.connect(audioCtx.destination);

async function loadMusic() {
  const res = await fetch("space.mp3");
  const buf = await res.arrayBuffer();
  musicBuffer = await audioCtx.decodeAudioData(buf);
}
loadMusic();

function startMusic() {
  if (!musicBuffer || musicSource) return;
  musicSource = audioCtx.createBufferSource();
  musicSource.buffer = musicBuffer;
  musicSource.loop = true;
  musicSource.connect(musicGain);
  musicSource.start();
}

function duckMusic(vol, t = 0.15) {
  musicGain.gain.setTargetAtTime(vol, audioCtx.currentTime, t);
}

function playTone(freq, dur, type="sine", vol=0.05) {
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = vol;
  o.connect(g);
  g.connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + dur);
}

// =====================================================
// BIOMES
// =====================================================
const BIOMES = [
  { skyTop:"#1b1e3c", skyBottom:"#3a3f7a", plantHue:160, structure:"#2a2d4a" },
  { skyTop:"#3b1126", skyBottom:"#7a2a4a", plantHue:330, structure:"#4a1f32" },
  { skyTop:"#0f2d3a", skyBottom:"#2fa4b8", plantHue:190, structure:"#163f4a" },
  { skyTop:"#3a2a10", skyBottom:"#a87a2f", plantHue:45,  structure:"#5a4218" },
  { skyTop:"#120f1f", skyBottom:"#3f2fa8", plantHue:280, structure:"#241c4a" }
];

function currentBiome() {
  return BIOMES[Math.floor((level - 1) / 5) % BIOMES.length];
}

// =====================================================
// GAME STATE
// =====================================================
let gravity = 1;
let alive = true;
let worldSpeed = 2.0;
let score = 0;
let level = 1;
let levelTarget = 30;
let levelFlash = 0;
let musicStarted = false;

const player = {
  x: canvas.width * 0.35,
  y: canvas.height / 2,
  r: 12,
  vy: 0,
  maxVy: 6
};

let obstacles = [];
let spawnTimer = 0;

// =====================================================
// THRUSTER PARTICLES
// =====================================================
let particles = [];

function spawnThruster(x, y, dir) {
  for (let i = 0; i < 10; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 1.2,
      vy: dir * (3 + Math.random() * 2),
      life: 22
    });
  }
}

// =====================================================
// INPUT
// =====================================================
function flip() {
  audioCtx.resume();
  if (!musicStarted) { startMusic(); musicStarted = true; }

  if (!alive) { restartLevel(); duckMusic(0.25); return; }

  gravity *= -1;
  spawnThruster(player.x, player.y + (gravity === 1 ? 18 : -18), gravity);
  playTone(520, 0.05, "square", 0.03);
}

window.addEventListener("mousedown", flip);
window.addEventListener("touchstart", e => {
  e.preventDefault(); flip();
}, { passive: false });

// =====================================================
// LEVEL FLOW
// =====================================================
function restartLevel() {
  gravity = 1;
  alive = true;
  score = 0;
  player.y = canvas.height / 2;
  player.vy = 0;
  obstacles = [];
  spawnTimer = 0;
}

function nextLevel() {
  level++;
  levelTarget += 15;
  worldSpeed += 0.35;
  player.maxVy += 0.3;
  levelFlash = 60;
  playTone(900, 0.2, "triangle", 0.07);
  restartLevel();
}

// =====================================================
// BACKGROUND + FOREGROUND PLANTS
// =====================================================
function drawBackground() {
  const b = currentBiome();
  const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
  grad.addColorStop(0, b.skyTop);
  grad.addColorStop(1, b.skyBottom);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = b.structure;
  for (let i = 0; i < 6; i++) {
    const x = (i * 300 + level * -40) % (canvas.width + 300);
    ctx.beginPath();
    ctx.moveTo(x, canvas.height);
    ctx.lineTo(x + 60, canvas.height - 120);
    ctx.lineTo(x + 120, canvas.height);
    ctx.fill();
  }
}

function drawForegroundPlants() {
  const b = currentBiome();
  for (let i = 0; i < 14; i++) {
    const x = (i * 180 + level * -80) % (canvas.width + 200);
    ctx.strokeStyle = `hsla(${b.plantHue},80%,65%,0.8)`;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x, canvas.height);
    ctx.quadraticCurveTo(x + 12, canvas.height - 50, x + 6, canvas.height - 100);
    ctx.stroke();

    ctx.fillStyle = `hsla(${b.plantHue+20},90%,70%,0.9)`;
    ctx.beginPath();
    ctx.arc(x + 6, canvas.height - 100, 5, 0, Math.PI * 2);
    ctx.fill();
  }
}

// =====================================================
// JETPACK ASTRONAUT (CUTE + CLEAR)
// =====================================================
function drawAstronaut(x, y, size, flipped) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(flipped ? Math.PI : 0);

  // Jetpack
  ctx.fillStyle = "#444";
  ctx.beginPath();
  ctx.roundRect(-size * 0.25, size * 0.4, size * 0.5, size * 0.35, 8);
  ctx.fill();

  // Body
  ctx.fillStyle = "#00ffd5";
  ctx.beginPath();
  ctx.roundRect(-size * 0.25, -size * 0.1, size * 0.5, size * 0.55, 10);
  ctx.fill();

  // Legs (dangling)
  ctx.fillStyle = "#ccc";
  ctx.fillRect(-6, size * 0.5, 4, 8);
  ctx.fillRect(2, size * 0.5, 4, 8);

  // Helmet
  ctx.fillStyle = "#eee";
  ctx.beginPath();
  ctx.arc(0, -size * 0.45, size * 0.42, 0, Math.PI * 2);
  ctx.fill();

  // Visor
  ctx.fillStyle = "#111";
  ctx.beginPath();
  ctx.arc(0.1 * size, -size * 0.45, size * 0.25, Math.PI * 0.2, Math.PI * 1.8);
  ctx.fill();

  ctx.restore();
}

// =====================================================
// OBSTACLES
// =====================================================
function spawnObstacle() {
  const gap = Math.max(130, canvas.height * 0.35 - level * 12);
  obstacles.push({
    x: canvas.width,
    width: canvas.width * 0.14,
    gapY: Math.random() * (canvas.height - gap),
    gap
  });
}

// =====================================================
// LOOP
// =====================================================
function update() {
  drawBackground();

  if (alive) {
    score += 0.02;
    player.vy += gravity * 0.45;
    player.vy = Math.max(-player.maxVy, Math.min(player.vy, player.maxVy));
    player.y += player.vy;

    spawnTimer += worldSpeed;
    if (spawnTimer > 200) {
      spawnObstacle();
      spawnTimer = 0;
    }

    for (let o of obstacles) {
      o.x -= worldSpeed;
      if (
        player.x + player.r > o.x &&
        player.x - player.r < o.x + o.width &&
        (player.y - player.r < o.gapY ||
         player.y + player.r > o.gapY + o.gap)
      ) {
        alive = false;
        playTone(140, 0.3, "sawtooth", 0.07);
        duckMusic(0.08);
      }
    }

    obstacles = obstacles.filter(o => o.x + o.width > 0);
    if (score >= levelTarget) nextLevel();
  }

  // Thrusters
  ctx.fillStyle = "#ffd27d";
  particles.forEach(p => {
    ctx.globalAlpha = p.life / 22;
    ctx.fillRect(p.x, p.y, 2, 2);
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
  });
  ctx.globalAlpha = 1;
  particles = particles.filter(p => p.life > 0);

  drawAstronaut(player.x, player.y, player.r * 2, gravity === -1);

  drawForegroundPlants();

  // Walls
  ctx.fillStyle = "#222";
  obstacles.forEach(o => {
    ctx.fillRect(o.x, 0, o.width, o.gapY);
    ctx.fillRect(o.x, o.gapY + o.gap, o.width, canvas.height);
  });

  // UI
  ctx.fillStyle = "#aaa";
  ctx.font = "16px monospace";
  ctx.fillText(`LEVEL ${level}`, 20, 24);
  ctx.fillText(`PROGRESS ${score.toFixed(1)} / ${levelTarget}`, 20, 44);

  if (levelFlash > 0) {
    levelFlash--;
    ctx.fillStyle = "#00ffd5";
    ctx.font = "28px monospace";
    ctx.textAlign = "center";
    ctx.fillText("LEVEL COMPLETE", canvas.width / 2, canvas.height / 2);
    ctx.textAlign = "left";
  }

  requestAnimationFrame(update);
}

update();
</script>
</body>
</html>
