<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>FLIP // FALL</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
  body {
    margin: 0;
    background: #0b0b0b;
    overflow: hidden;
    touch-action: manipulation;
  }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
// =====================================================
// CANVAS
// =====================================================
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

// =====================================================
// AUDIO
// =====================================================
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioCtx();

let musicBuffer = null;
let musicSource = null;
let musicGain = audioCtx.createGain();
musicGain.gain.value = 0.25;
musicGain.connect(audioCtx.destination);

async function loadMusic() {
  const res = await fetch("space.mp3");
  const buf = await res.arrayBuffer();
  musicBuffer = await audioCtx.decodeAudioData(buf);
}
loadMusic();

function startMusic() {
  if (!musicBuffer || musicSource) return;
  musicSource = audioCtx.createBufferSource();
  musicSource.buffer = musicBuffer;
  musicSource.loop = true;
  musicSource.connect(musicGain);
  musicSource.start();
}

function duckMusic(vol, t = 0.15) {
  musicGain.gain.setTargetAtTime(vol, audioCtx.currentTime, t);
}

function playTone(freq, dur, type="sine", vol=0.05) {
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = vol;
  o.connect(g);
  g.connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + dur);
}

// =====================================================
// GAME STATE
// =====================================================
let gravity = 1;
let alive = true;
let worldSpeed = 2.0;
let score = 0;
let level = 1;
let levelTarget = 30;
let levelFlash = 0;
let musicStarted = false;

const player = {
  x: canvas.width * 0.35,
  y: canvas.height / 2,
  r: 12,
  vy: 0,
  maxVy: 6
};

let obstacles = [];
let spawnTimer = 0;

// =====================================================
// THRUSTER PARTICLES (THIS IS THE IMPORTANT PART)
// =====================================================
let particles = [];

function spawnThruster(x, y, dir) {
  for (let i = 0; i < 8; i++) {
    particles.push({
      x,
      y,
      vx: (Math.random() - 0.5) * 1.4,
      vy: dir * (2.5 + Math.random() * 1.5),
      life: 20
    });
  }
}

// =====================================================
// INPUT
// =====================================================
function flip() {
  audioCtx.resume();

  if (!musicStarted) {
    startMusic();
    musicStarted = true;
  }

  if (!alive) {
    restartLevel();
    duckMusic(0.25);
    return;
  }

  gravity *= -1;
  spawnThruster(player.x, player.y, gravity); // ðŸ”¥ THRUSTER HERE
  playTone(520, 0.05, "square", 0.03);
}

window.addEventListener("mousedown", flip);
window.addEventListener("touchstart", e => {
  e.preventDefault();
  flip();
}, { passive: false });

// =====================================================
// LEVEL FLOW
// =====================================================
function restartLevel() {
  gravity = 1;
  alive = true;
  score = 0;
  player.y = canvas.height / 2;
  player.vy = 0;
  obstacles = [];
  spawnTimer = 0;
}

function nextLevel() {
  level++;
  levelTarget += 15;
  worldSpeed += 0.35;
  player.maxVy += 0.3;
  levelFlash = 60;
  playTone(900, 0.2, "triangle", 0.07);
  restartLevel();
}

// =====================================================
// ASTRONAUT
// =====================================================
function drawAstronaut(x, y, size, flipped) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(flipped ? Math.PI : 0);

  ctx.fillStyle = "#555";
  ctx.fillRect(-size * 0.6, -size * 0.2, size * 0.3, size * 0.6);

  ctx.fillStyle = "#00ffd5";
  ctx.beginPath();
  ctx.roundRect(-size * 0.35, -size * 0.1, size * 0.7, size * 0.9, 6);
  ctx.fill();

  ctx.fillStyle = "#eee";
  ctx.beginPath();
  ctx.arc(0, -size * 0.4, size * 0.35, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "#222";
  ctx.beginPath();
  ctx.arc(0.1 * size, -size * 0.45, size * 0.2, Math.PI * 0.2, Math.PI * 1.8);
  ctx.fill();

  ctx.restore();
}

// =====================================================
// OBSTACLES
// =====================================================
function spawnObstacle() {
  const gap = Math.max(130, canvas.height * 0.35 - level * 12);
  obstacles.push({
    x: canvas.width,
    width: canvas.width * 0.14,
    gapY: Math.random() * (canvas.height - gap),
    gap
  });
}

// =====================================================
// GAME LOOP
// =====================================================
function update() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (alive) {
    score += 0.02;

    player.vy += gravity * 0.45;
    player.vy = Math.max(-player.maxVy, Math.min(player.vy, player.maxVy));
    player.y += player.vy;

    spawnTimer += worldSpeed;
    if (spawnTimer > 200) {
      spawnObstacle();
      spawnTimer = 0;
    }

    for (let o of obstacles) {
      o.x -= worldSpeed;
      if (
        player.x + player.r > o.x &&
        player.x - player.r < o.x + o.width
      ) {
        if (
          player.y - player.r < o.gapY ||
          player.y + player.r > o.gapY + o.gap
        ) {
          alive = false;
          playTone(140, 0.3, "sawtooth", 0.07);
          duckMusic(0.08);
        }
      }
    }

    obstacles = obstacles.filter(o => o.x + o.width > 0);

    if (player.y < -30 || player.y > canvas.height + 30) {
      alive = false;
      playTone(140, 0.3, "sawtooth", 0.07);
      duckMusic(0.08);
    }

    if (score >= levelTarget) nextLevel();
  }

  // ---------- DRAW THRUSTER PARTICLES ----------
  ctx.fillStyle = "#aaa";
  particles.forEach(p => {
    ctx.globalAlpha = p.life / 20;
    ctx.fillRect(p.x, p.y, 2, 2);
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
  });
  ctx.globalAlpha = 1;
  particles = particles.filter(p => p.life > 0);

  // ---------- DRAW PLAYER ----------
  drawAstronaut(player.x, player.y, player.r * 2, gravity === -1);

  // ---------- DRAW WALLS ----------
  ctx.fillStyle = "#222";
  for (let o of obstacles) {
    ctx.fillRect(o.x, 0, o.width, o.gapY);
    ctx.fillRect(o.x, o.gapY + o.gap, o.width, canvas.height);
  }

  // ---------- UI ----------
  ctx.fillStyle = "#888";
  ctx.font = "16px monospace";
  ctx.fillText(`LEVEL ${level}`, 20, 24);
  ctx.fillText(`PROGRESS ${score.toFixed(1)} / ${levelTarget}`, 20, 44);

  if (!alive) {
    ctx.fillStyle = "#fff";
    ctx.font = "22px monospace";
    ctx.textAlign = "center";
    ctx.fillText("TAP TO RETRY LEVEL", canvas.width / 2, canvas.height / 2);
    ctx.textAlign = "left";
  }

  if (levelFlash > 0) {
    levelFlash--;
    ctx.fillStyle = "#00ffd5";
    ctx.font = "28px monospace";
    ctx.textAlign = "center";
    ctx.fillText("LEVEL COMPLETE", canvas.width / 2, canvas.height / 2);
    ctx.textAlign = "left";
  }

  requestAnimationFrame(update);
}

update();
</script>
</body>
</html>
