<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>FLIP // FALL</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
body {
  margin: 0;
  background: #000;
  overflow: hidden;
  touch-action: manipulation;
}
canvas { display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
// =====================================================
// CANVAS
// =====================================================
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
addEventListener("resize", resize);
resize();

// =====================================================
// TAP INPUT
// =====================================================
let tapX=null, tapY=null;
let spX=0, spY=0, spW=0, spH=0;

canvas.addEventListener("touchstart", e=>{
  const t=e.touches[0];
  tapX=t.clientX;
  tapY=t.clientY;

  if(
    tapX>=spX && tapX<=spX+spW &&
    tapY>=spY && tapY<=spY+spH
  ){
    e.preventDefault();
    return;
  }

  if(state==="playing"){
    e.preventDefault();
    flip();
  }
},{ passive:false });

canvas.addEventListener("mousedown", e=>{
  tapX=e.clientX;
  tapY=e.clientY;
  if(state==="playing") flip();
});

function consumeTap(x,y,w,h){
  if(tapX!==null &&
     tapX>=x && tapX<=x+w &&
     tapY>=y && tapY<=y+h){
    tapX=tapY=null;
    return true;
  }
  return false;
}

// =====================================================
// AUDIO
// =====================================================
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioCtx();

let musicBuffer=null, musicSource=null;
const musicGain=audioCtx.createGain();
musicGain.gain.value=0.25;
musicGain.connect(audioCtx.destination);

fetch("space.mp3")
  .then(r=>r.arrayBuffer())
  .then(b=>audioCtx.decodeAudioData(b))
  .then(b=>musicBuffer=b);

function startMusic(){
  if(!musicBuffer||musicSource) return;
  musicSource=audioCtx.createBufferSource();
  musicSource.buffer=musicBuffer;
  musicSource.loop=true;
  musicSource.connect(musicGain);
  musicSource.start();
}
function stopMusic(){
  if(musicSource){ musicSource.stop(); musicSource=null; }
}
function playTone(f,d,t="sine",v=0.05){
  const o=audioCtx.createOscillator(), g=audioCtx.createGain();
  o.type=t; o.frequency.value=f;
  g.gain.value=v;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime+d);
}

// =====================================================
// HAPTICS
// =====================================================
function haptic(ms=20){
  if(navigator.vibrate) navigator.vibrate(ms);
}

// =====================================================
// DATA
// =====================================================
const BIOMES=[
  { sky:["#14173a","#2c3172"], structure:"#2b315f" },
  { sky:["#2a0e1f","#6a2a4a"], structure:"#532334" },
  { sky:["#0a2633","#1e8fa6"], structure:"#10495b" },
  { sky:["#2b200b","#9a6b26"], structure:"#5f4214" },
  { sky:["#120b26","#4b3cb3"], structure:"#2a2266" }
];
const SUIT_COLORS=[
  "#00ffd5","#ff9ad5","#ffd966",
  "#7dffd5","#b79cff","#ffb86c","#9cff8a"
];

// =====================================================
// STATE
// =====================================================
let state="title";
let mode=null;

let gravity=1;
let alive=true;
let level=1;
let lives=5;
let flips=0;

let worldSpeed=2;
let levelDistance=0;
let levelTarget=1800;

let deathTimer=0;
  
 let suitIndex = 0;


// run stats
let runStartTime=0;
let runDuration=0;
let deathsThisRun=0;
let bombsUsed=0;

// bombs / jetpack
let hasBomb=false;
let bombsLeft=0;
let bombCooldown=0;

let hasJetpack=false;
let jetFuel=0;
let jetActive=false;

const JET_THRUST=0.9;
const JET_DRAIN=1;

// =====================================================
// PLAYER
// =====================================================
const player={ x:0,y:0,vy:0,r:12,maxVy:6 };
let obstacles=[], spawnTimer=0, particles=[];

// =====================================================
// HELPERS
// =====================================================
const biome=()=>BIOMES[(level-1)%BIOMES.length];
const suitColor=()=>SUIT_COLORS[suitIndex];

// =====================================================
// INPUT
// =====================================================
function flip(){
  if(state!=="playing"||!alive||jetActive) return;
  audioCtx.resume();
  startMusic();
  gravity*=-1;
  flips++;
  spawnThruster(player.x-18,player.y+gravity*14,gravity,suitColor());
  playTone(520,0.05,"square",0.03);
}

// =====================================================
// SPECIAL ACTION
// =====================================================
function useSpecial(){
  if(!alive||state!=="playing") return;

  if(hasBomb && bombsLeft>0 && bombCooldown<=0){
    const idx=obstacles.findIndex(o=>o.x+o.width>player.x);
    if(idx!==-1){
      const o=obstacles[idx];
      spawnExplosion(o.x+o.width/2,o.gapY+o.gap/2,biome().structure);
      obstacles.splice(idx,1);
      bombsLeft--;
      bombsUsed++;
      bombCooldown=40;
      playTone(180,0.3,"square",0.07);
      haptic(25);
      return;
    }
  }

  if(hasJetpack && jetFuel>0){
    jetActive=!jetActive;
    playTone(720,0.15,"triangle",0.05);
  }
}

// =====================================================
// PARTICLES
// =====================================================
function spawnThruster(x,y,d,c){
  for(let i=0;i<16;i++){
    particles.push({
      x,y,
      vx:(Math.random()-0.5)*2,
      vy:d*(3+Math.random()*2),
      life:28,
      color:c
    });
  }
}
function spawnExplosion(x,y,color){
  for(let i=0;i<40;i++){
    particles.push({
      x,y,
      vx:(Math.random()-0.5)*6,
      vy:(Math.random()-0.5)*6,
      life:40,
      color
    });
  }
}

// =====================================================
// FLOW
// =====================================================
function restart(){
  alive=true;
  gravity=1;
  player.vy=0;
  obstacles=[];
  spawnTimer=0;
  jetActive=false;
  player.x=canvas.width*0.35;
  player.y=canvas.height/2;
}

function unlockUpgrade(){
  if(level===3){ hasBomb=true; bombsLeft=5; }
  if(level===5){ hasJetpack=true; jetFuel=300; }
}

function handleDeath(){
  if(!alive) return;

  deathsThisRun++;
  lives--;
  alive=false;
  deathTimer=30;
  playTone(140,0.25,"sine",0.06);
  haptic(30);

  if(lives<=0){
  runDuration = Math.floor((performance.now()-runStartTime)/1000);
  stopMusic();
  tapX = tapY = null;   // â† ADD THIS
  state="recap";
}
}

function restartRun(){
  state="playing";
  level=1;
  lives=5;
  flips=0;
  deathsThisRun=0;
  bombsUsed=0;
  runStartTime=performance.now();
  hasBomb=false;
  hasJetpack=false;
  bombsLeft=0;
  jetFuel=0;
  levelDistance=0;
  restart();
}

// =====================================================
// BACKGROUND
// =====================================================
function drawBackground(){
  const b=biome();
  const g=ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0,b.sky[0]);
  g.addColorStop(1,b.sky[1]);
  ctx.fillStyle=g;
  ctx.fillRect(0,0,canvas.width,canvas.height);
}

function drawRuins(){
  const b=biome();
  ctx.fillStyle=b.structure+"88";
  for(let i=0;i<8;i++){
    const x=i*240-(levelDistance*0.3)%240;
    const h=80+Math.sin(i+level)*40;
    ctx.fillRect(x,canvas.height-h,120,h);
  }
}

// =====================================================
// DRAWING
// =====================================================
function drawAstronaut(){
  ctx.save();
  ctx.translate(player.x,player.y);
  ctx.rotate(gravity===-1?Math.PI:0);
  ctx.fillStyle="#444";
  ctx.fillRect(-28,-18,14,36);
  ctx.fillStyle=suitColor();
  ctx.fillRect(-7,-3,14,20);
  ctx.fillStyle="#eee";
  ctx.beginPath();
  ctx.arc(0,-14,11,0,Math.PI*2);
  ctx.fill();
  ctx.fillStyle="#111";
  ctx.beginPath();
  ctx.ellipse(2,-14,6,4,0,0,Math.PI*2);
  ctx.fill();
  ctx.restore();
}

// =====================================================
// OBSTACLES
// =====================================================
function spawnObstacle(){
  const gap=Math.max(130,canvas.height*0.35-level*10);
  obstacles.push({
    x:canvas.width,
    width:canvas.width*0.14,
    gapY:Math.random()*(canvas.height-gap),
    gap
  });
}

// =====================================================
// UI BUTTON
// =====================================================
function drawButtons(){
  const size=72;
  const x=20;
  const y=canvas.height-size-20;
  spX=x; spY=y; spW=size; spH=size;
  ctx.globalAlpha=0.35;
  ctx.fillStyle="#fff";
  ctx.fillRect(x,y,size,size);
  ctx.globalAlpha=1;
  ctx.fillStyle="#000";
  ctx.font="16px monospace";
  ctx.fillText("SP",x+20,y+46);
  if(consumeTap(x,y,size,size)) useSpecial();
}

// =====================================================
// MAIN LOOP
// =====================================================
function update(){
  if(state==="playing"){
    drawBackground();
    drawRuins();

    if(alive){
      levelDistance+=worldSpeed;

      if(jetActive && jetFuel>0){
        player.vy-=gravity*JET_THRUST;
        jetFuel-=JET_DRAIN;
        if(jetFuel<=0) jetActive=false;
      } else {
        player.vy+=gravity*0.45;
      }

      player.vy=Math.max(-player.maxVy,Math.min(player.vy,player.maxVy));
      player.y+=player.vy;

      spawnTimer+=worldSpeed;
      if(spawnTimer>260){ spawnObstacle(); spawnTimer=0; }

      for(const o of obstacles){
        o.x-=worldSpeed;
        if(
          player.x+player.r>o.x &&
          player.x-player.r<o.x+o.width &&
          (player.y-player.r<o.gapY || player.y+player.r>o.gapY+o.gap)
        ){
          handleDeath();
          break;
        }
      }

      obstacles=obstacles.filter(o=>o.x+o.width>0);

      if(levelDistance>=levelTarget){
  level++;
  levelTarget=1800+level*300;
  levelDistance = 0;   // â† REQUIRED
  unlockUpgrade();
  restart();
}

    }

    // ðŸ”§ POST-DEATH RECOVERY (RESTORED)
    if(!alive && deathTimer > 0){
      deathTimer--;
      if(deathTimer === 0 && lives > 0){
        restart();
      }
    }

    // PARTICLES
    particles.forEach(p=>{
      ctx.globalAlpha=p.life/28;
      ctx.fillStyle=p.color;
      ctx.fillRect(p.x,p.y,2,2);
      p.x+=p.vx;
      p.y+=p.vy;
      p.life--;
    });
    ctx.globalAlpha=1;
    particles=particles.filter(p=>p.life>0);

    drawAstronaut();
    drawButtons();

    ctx.fillStyle="#2a2a2a";
    obstacles.forEach(o=>{
      ctx.fillRect(o.x,0,o.width,o.gapY);
      ctx.fillRect(o.x,o.gapY+o.gap,o.width,canvas.height);
    });

    ctx.fillStyle="#eee";
    ctx.font="16px monospace";
    ctx.fillText(`LEVEL ${level}`,20,24);
    ctx.fillText(`LIVES ${lives}`,20,44);
    if(hasBomb) ctx.fillText(`BOMBS ${bombsLeft}`,20,64);
    if(hasJetpack) ctx.fillText(`FUEL ${jetFuel}`,20,84);
  }

  if(state==="title") drawTitle();
  if(state==="recap") drawRecap();

  if(bombCooldown>0) bombCooldown--;
  requestAnimationFrame(update);
}

// =====================================================
// TITLE / RECAP
// =====================================================
function drawTitle(){
  ctx.fillStyle="#000c";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle="#fff";
  ctx.textAlign="center";
  ctx.font="28px monospace";
  ctx.fillText("FLIP // FALL",canvas.width/2,canvas.height*0.25);
  ctx.font="20px monospace";
  
  // COLOR SELECT (BOTTOM CENTER)
ctx.font = "16px monospace";
ctx.textAlign = "center";

const cy = canvas.height * 0.82;
const cx = canvas.width / 2;

// label
ctx.fillStyle = "#fff";
ctx.fillText("SUIT COLOR", cx, cy - 28);

// left arrow
const cw = 40, ch = 40;
if(consumeTap(cx - 90, cy - ch/2, cw, ch)){
  suitIndex = (suitIndex - 1 + SUIT_COLORS.length) % SUIT_COLORS.length;
  playTone(420,0.05,"square",0.03);
}
ctx.fillText("â—€", cx - 90, cy + 10);

// right arrow
if(consumeTap(cx + 50, cy - ch/2, cw, ch)){
  suitIndex = (suitIndex + 1) % SUIT_COLORS.length;
  playTone(520,0.05,"square",0.03);
}
ctx.fillText("â–¶", cx + 50, cy + 10);

// color preview
ctx.fillStyle = SUIT_COLORS[suitIndex];
ctx.fillRect(cx - 15, cy - 15, 30, 30);

// reset alignment (important)
ctx.textAlign = "center";



  const buttons=[
    {label:"ZEN",y:0.45,action:()=>{mode="zen";restartRun();}},
    {label:"STANDARD",y:0.55,action:()=>{mode="standard";restartRun();}},
    {label:"CLASSIC",y:0.65,action:()=>{mode="classic";restartRun();}}
  ];

  buttons.forEach(b=>{
    const w=260,h=52;
    const x=canvas.width/2-w/2;
    const y=canvas.height*b.y-h/2;
    ctx.fillStyle="#222";
    ctx.fillRect(x,y,w,h);
    ctx.strokeStyle="#666";
    ctx.strokeRect(x,y,w,h);
    ctx.fillStyle="#fff";
    ctx.fillText(b.label,canvas.width/2,y+34);
    if(consumeTap(x,y,w,h)) b.action();
  });
}

function drawRecap(){
  ctx.fillStyle="#000c";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle="#fff";
  ctx.textAlign="center";
  ctx.font="26px monospace";
  ctx.fillText("RUN COMPLETE",canvas.width/2,canvas.height*0.22);
  ctx.font="18px monospace";
  ctx.fillText(`LEVELS ${level-1}`,canvas.width/2,canvas.height*0.32);
  ctx.fillText(`FLIPS ${flips}`,canvas.width/2,canvas.height*0.38);
  ctx.fillText(`TIME ${runDuration}s`,canvas.width/2,canvas.height*0.44);
  ctx.fillText(`DEATHS ${deathsThisRun}`,canvas.width/2,canvas.height*0.50);
  ctx.fillText(`BOMBS USED ${bombsUsed}`,canvas.width/2,canvas.height*0.56);
  ctx.font="20px monospace";
  ctx.fillText("TAP TO RESTART",canvas.width/2,canvas.height*0.7);
  if(tapX!==null){
  tapX = tapY = null;
  restartRun();
}

}

// INIT
update();
</script>
</body>
</html>
