<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>FLIP // FALL</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
  body {
    margin: 0;
    background: #0b0b0b;
    overflow: hidden;
    touch-action: manipulation;
  }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

// ---------- AUDIO ----------
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioCtx();

function playTone(freq, duration, type = "sine", volume = 0.05) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.value = volume;
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

// ---------- GAME STATE ----------
let gravity = 1;
let worldSpeed = 2.0;
let score = 0;
let alive = true;
let obstacleCount = 0;

const player = {
  x: canvas.width * 0.35,
  y: canvas.height / 2,
  r: 12,
  vy: 0,
  maxVy: 6
};

// ---------- COLORS ----------
const colorUnlocks = [
  { score: 0, color: "#00ffd5" },
  { score: 20, color: "#ffd500" },
  { score: 50, color: "#ff7a00" },
  { score: 90, color: "#ff0044" },
  { score: 140, color: "#9b5cff" }
];

let currentColor = colorUnlocks[0].color;

// ---------- PARTICLES ----------
let particles = [];

function spawnThruster(x, y, dir) {
  for (let i = 0; i < 6; i++) {
    particles.push({
      x,
      y,
      vx: (Math.random() - 0.5) * 1.5,
      vy: dir * (2 + Math.random() * 1.5),
      life: 20
    });
  }
}

// ---------- INPUT ----------
function flip() {
  if (!alive) {
    restart();
    return;
  }
  gravity *= -1;
  spawnThruster(player.x, player.y, gravity);
  playTone(600, 0.05, "square", 0.04);
}
window.addEventListener("mousedown", flip);
window.addEventListener("touchstart", e => {
  e.preventDefault();
  audioCtx.resume();
  flip();
}, { passive: false });

// ---------- RESET ----------
function restart() {
  gravity = 1;
  worldSpeed = 2.0;
  score = 0;
  alive = true;
  obstacleCount = 0;
  player.y = canvas.height / 2;
  player.vy = 0;
  obstacles = [];
  spawnTimer = 0;
  currentColor = colorUnlocks[0].color;
}

// ---------- ASTRONAUT ----------
function drawAstronaut(x, y, size, flipped, color) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(flipped ? Math.PI : 0);

  ctx.fillStyle = "#555";
  ctx.fillRect(-size * 0.6, -size * 0.2, size * 0.3, size * 0.6);

  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.roundRect(-size * 0.35, -size * 0.1, size * 0.7, size * 0.9, 6);
  ctx.fill();

  ctx.fillStyle = "#eee";
  ctx.beginPath();
  ctx.arc(0, -size * 0.4, size * 0.35, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "#222";
  ctx.beginPath();
  ctx.arc(0.1 * size, -size * 0.45, size * 0.2, Math.PI * 0.2, Math.PI * 1.8);
  ctx.fill();

  ctx.restore();
}

// ---------- OBSTACLES ----------
let obstacles = [];
let spawnTimer = 0;

function spawnObstacle() {
  obstacleCount++;

  const gapSize = obstacleCount <= 3
    ? canvas.height * 0.45
    : Math.max(130, canvas.height * 0.35 - score * 3);

  const gapY = obstacleCount <= 3
    ? (canvas.height - gapSize) / 2
    : Math.random() * (canvas.height - gapSize);

  obstacles.push({
    x: canvas.width,
    width: canvas.width * 0.14,
    gapY,
    gap: gapSize
  });
}

// ---------- LOOP ----------
function update() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (alive) {
    score += 0.02;
    worldSpeed += 0.0002;

    for (let c of colorUnlocks) {
      if (score > c.score && currentColor !== c.color) {
        currentColor = c.color;
        playTone(900, 0.12, "triangle", 0.06);
      }
    }

    player.vy += gravity * 0.45;
    player.vy = Math.max(-player.maxVy, Math.min(player.vy, player.maxVy));
    player.y += player.vy;

    spawnTimer += worldSpeed;
    if (spawnTimer > 200) {
      spawnObstacle();
      spawnTimer = 0;
    }

    for (let o of obstacles) {
      o.x -= worldSpeed;
      if (
        player.x + player.r > o.x &&
        player.x - player.r < o.x + o.width
      ) {
        if (
          player.y - player.r < o.gapY ||
          player.y + player.r > o.gapY + o.gap
        ) {
          alive = false;
          playTone(120, 0.25, "sawtooth", 0.08);
        }
      }
    }

    obstacles = obstacles.filter(o => o.x + o.width > 0);

    if (player.y < -30 || player.y > canvas.height + 30) {
      alive = false;
      playTone(120, 0.25, "sawtooth", 0.08);
    }
  }

  // ---------- PARTICLES ----------
  ctx.fillStyle = "#aaa";
  particles.forEach(p => {
    ctx.globalAlpha = p.life / 20;
    ctx.fillRect(p.x, p.y, 2, 2);
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
  });
  ctx.globalAlpha = 1;
  particles = particles.filter(p => p.life > 0);

  // ---------- DRAW ----------
  drawAstronaut(
    player.x,
    player.y,
    player.r * 2,
    gravity === -1,
    currentColor
  );

  ctx.fillStyle = "#222";
  for (let o of obstacles) {
    ctx.fillRect(o.x, 0, o.width, o.gapY);
    ctx.fillRect(o.x, o.gapY + o.gap, o.width, canvas.height);
  }

  ctx.fillStyle = "#888";
  ctx.font = "16px monospace";
  ctx.fillText(`DISTANCE ${score.toFixed(1)}`, 20, 30);

  if (!alive) {
    ctx.fillStyle = "#fff";
    ctx.font = "24px monospace";
    ctx.textAlign = "center";
    ctx.fillText("TAP TO RESTART", canvas.width / 2, canvas.height / 2);
    ctx.textAlign = "left";
  }

  requestAnimationFrame(update);
}

update();
</script>
</body>
</html>
