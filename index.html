<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>FLIP // FALL</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
body { margin:0; background:#000; overflow:hidden; touch-action:manipulation; }
canvas { display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
// =====================================================
// CANVAS
// =====================================================
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
function resize(){ canvas.width=innerWidth; canvas.height=innerHeight; }
addEventListener("resize",resize); resize();

// =====================================================
// AUDIO
// =====================================================
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioCtx();
let musicBuffer=null, musicSource=null;
const musicGain = audioCtx.createGain();
musicGain.gain.value=0.25;
musicGain.connect(audioCtx.destination);

fetch("space.mp3")
  .then(r=>r.arrayBuffer())
  .then(b=>audioCtx.decodeAudioData(b))
  .then(b=>musicBuffer=b);

function startMusic(){
  if(!musicBuffer||musicSource) return;
  musicSource=audioCtx.createBufferSource();
  musicSource.buffer=musicBuffer;
  musicSource.loop=true;
  musicSource.connect(musicGain);
  musicSource.start();
}

function playTone(f,d,t="sine",v=0.05){
  const o=audioCtx.createOscillator(), g=audioCtx.createGain();
  o.type=t; o.frequency.value=f; g.gain.value=v;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime+d);
}

// =====================================================
// HAPTICS
// =====================================================
function haptic(ms=20){
  if(navigator.vibrate) navigator.vibrate(ms);
}

// =====================================================
// BIOMES + COLORS
// =====================================================
const BIOMES=[
 { sky:["#1b1e3c","#3a3f7a"], plant:0, structure:"#2a2d4a" },
 { sky:["#3b1126","#7a2a4a"], plant:1, structure:"#4a1f32" },
 { sky:["#0f2d3a","#2fa4b8"], plant:2, structure:"#163f4a" },
 { sky:["#3a2a10","#a87a2f"], plant:3, structure:"#5a4218" },
 { sky:["#120f1f","#3f2fa8"], plant:4, structure:"#241c4a" }
];

const SUIT_COLORS=[
 "#00ffd5","#ff9ad5","#ffd966",
 "#7dffd5","#b79cff","#ffb86c","#9cff8a"
];

const biome=()=>BIOMES[(level-1)%BIOMES.length];
const suitColor=()=>SUIT_COLORS[(level-1)%SUIT_COLORS.length];
const structureTier=()=>Math.floor((level-1)/2)%3;

// =====================================================
// GAME STATE
// =====================================================
let gravity=1, alive=true, started=false, mode=null;
let level=1, score=0, levelTarget=30, worldSpeed=2;
let lives=5, savedLevel=1;
let inputLocked=false;

const player={
 x:0,y:0,vy:0,r:12,maxVy:6,trail:[]
};

let obstacles=[], spawnTimer=0, particles=[];

// =====================================================
// INPUT â€” GAMEPLAY
// =====================================================
function flip(){
 if(!started||inputLocked) return;
 audioCtx.resume(); startMusic();
 if(!alive){ restart(); return; }

 gravity*=-1;
 spawnThruster(player.x-18,player.y,gravity,suitColor());
 playTone(520,0.05,"square",0.03);
}

canvas.addEventListener("touchstart",e=>{
 if(started){ e.preventDefault(); flip(); }
},{passive:false});
canvas.addEventListener("mousedown",()=>{ if(started) flip(); });

// =====================================================
// PARTICLES
// =====================================================
function spawnThruster(x,y,d,c){
 for(let i=0;i<8;i++){
  particles.push({
   x,y,
   vx:(Math.random()-.5)*1.2,
   vy:d*(3+Math.random()*2),
   life:22,
   color:c
  });
 }
}

// =====================================================
// FLOW
// =====================================================
function restart(){
 alive=true; gravity=1;
 player.x=canvas.width*0.35;
 player.y=canvas.height/2;
 player.vy=0;
 obstacles=[]; spawnTimer=0;
 player.trail=[];
}

function nextLevel(){
 level++; score=0; levelTarget+=15;
 worldSpeed+=0.35; player.maxVy+=0.3;
 if(mode==="standard") savedLevel=Math.max(savedLevel,level);
 playTone(900,0.2,"triangle",0.07);
 restart();
}

// =====================================================
// MODE SELECT UI (ANIMATED)
// =====================================================
let modeAnim=0, pressedButton=null;

canvas.addEventListener("touchend",e=>{
 if(started) return;
 const t=e.changedTouches[0];
 handleModeTap(t.clientX,t.clientY);
});
canvas.addEventListener("mouseup",e=>{
 if(started) return;
 handleModeTap(e.clientX,e.clientY);
});

function handleModeTap(x,y){
 const buttons=[
  {name:"zen",label:"ZEN",y:0.45},
  {name:"standard",label:"STANDARD",y:0.55},
  {name:"classic",label:"CLASSIC",y:0.65}
 ];
 for(const b of buttons){
  const w=260,h=52;
  const bx=canvas.width/2-w/2;
  const by=canvas.height*b.y+(1-modeAnim)*40;
  if(x>=bx&&x<=bx+w&&y>=by&&y<=by+h){
   pressedButton=b.label;
   haptic(25); playTone(660,0.08,"triangle",0.04);
   setTimeout(()=>{ startGame(b.name); pressedButton=null; },120);
   break;
  }
 }
}

function startGame(m){
 mode=m; started=true; inputLocked=true;
 level=1; score=0; lives=5; savedLevel=1;
 restart();
 setTimeout(()=>inputLocked=false,60);
}

function drawModeSelect(){
 modeAnim=Math.min(1,modeAnim+0.04);
 ctx.fillStyle="#000c"; ctx.fillRect(0,0,canvas.width,canvas.height);
 ctx.fillStyle="#fff"; ctx.font="28px monospace";
 ctx.textAlign="center"; ctx.globalAlpha=modeAnim;
 ctx.fillText("SELECT MODE",canvas.width/2,canvas.height*0.22);
 ctx.globalAlpha=1;
 drawButton("ZEN",0.45);
 drawButton("STANDARD",0.55);
 drawButton("CLASSIC",0.65);
 ctx.textAlign="left";
}

function drawButton(label,yRatio){
 const w=260,h=52;
 const x=canvas.width/2-w/2;
 const y=canvas.height*yRatio+(1-modeAnim)*40;
 const pressed=pressedButton===label;
 const scale=pressed?0.96:1;

 ctx.save();
 ctx.translate(canvas.width/2,y+h/2);
 ctx.scale(scale,scale);
 ctx.translate(-canvas.width/2,-(y+h/2));
 ctx.fillStyle=pressed?"#333":"#222";
 ctx.fillRect(x,y,w,h);
 ctx.strokeStyle="#666"; ctx.strokeRect(x,y,w,h);
 ctx.fillStyle="#fff"; ctx.font="20px monospace";
 ctx.textAlign="center";
 ctx.fillText(label,canvas.width/2,y+34);
 ctx.restore();
}

// =====================================================
// WORLD DRAWING
// =====================================================
function drawBackground(){
 const b=biome();
 const g=ctx.createLinearGradient(0,0,0,canvas.height);
 g.addColorStop(0,b.sky[0]); g.addColorStop(1,b.sky[1]);
 ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);

 ctx.fillStyle=b.structure;
 for(let i=0;i<6;i++){
  const x=(i*320+level*-40)%(canvas.width+320);
  ctx.beginPath();
  if(structureTier()===0){
   ctx.moveTo(x,canvas.height);
   ctx.lineTo(x+70,canvas.height-120);
   ctx.lineTo(x+140,canvas.height);
  }else if(structureTier()===1){
   ctx.moveTo(x,canvas.height);
   ctx.lineTo(x+50,canvas.height-160);
   ctx.lineTo(x+100,canvas.height);
  }else{
   ctx.rect(x,canvas.height-160,60,160);
   ctx.rect(x+80,canvas.height-120,40,120);
  }
  ctx.fill();
 }
}

function drawPlants(){
 const p=biome().plant;
 for(let i=0;i<14;i++){
  const x=(i*180+level*-80)%(canvas.width+200);
  ctx.strokeStyle=`hsla(${p*70},80%,65%,0.85)`;
  ctx.lineWidth=3; ctx.beginPath();
  ctx.moveTo(x,canvas.height);
  if(p===0) ctx.quadraticCurveTo(x+10,canvas.height-60,x,canvas.height-120);
  if(p===1) ctx.lineTo(x,canvas.height-120);
  if(p===2) ctx.lineTo(x+6,canvas.height-140);
  if(p===3) ctx.quadraticCurveTo(x-10,canvas.height-40,x,canvas.height-100);
  if(p===4) ctx.quadraticCurveTo(x+20,canvas.height-80,x,canvas.height-160);
  ctx.stroke();
 }
}

// =====================================================
// ASTRONAUT (RESTORED)
// =====================================================
function drawAstronaut(){
 const c=suitColor();

 if(level>=5){
  ctx.globalAlpha=0.35;
  ctx.shadowColor=c; ctx.shadowBlur=25;
  ctx.fillStyle=c;
  ctx.beginPath();
  ctx.arc(player.x,player.y,22,0,Math.PI*2);
  ctx.fill();
  ctx.shadowBlur=0; ctx.globalAlpha=1;
 }

 ctx.fillStyle="#444";
 ctx.fillRect(player.x-26,player.y-16,12,32);

 ctx.save();
 ctx.translate(player.x,player.y);
 ctx.rotate(gravity===-1?Math.PI:0);

 ctx.fillStyle=c;
 ctx.fillRect(-6,-2,12,18);

 ctx.fillStyle="#ddd";
 ctx.beginPath();
 ctx.arc(0,-12,10,0,Math.PI*2);
 ctx.fill();

 ctx.fillStyle="#111";
 ctx.beginPath();
 ctx.arc(2,-12,5,0,Math.PI*2);
 ctx.fill();
 ctx.restore();
}

// =====================================================
// OBSTACLES
// =====================================================
function spawnObstacle(){
 const gap=Math.max(130,canvas.height*0.35-level*12);
 obstacles.push({
  x:canvas.width,
  width:canvas.width*0.14,
  gapY:Math.random()*(canvas.height-gap),
  gap
 });
}

// =====================================================
// MAIN LOOP
// =====================================================
function update(){
 drawBackground();

 if(started&&alive){
  score+=0.02;
  player.vy+=gravity*0.45;
  player.vy=Math.max(-player.maxVy,Math.min(player.vy,player.maxVy));
  player.y+=player.vy;

  spawnTimer+=worldSpeed;
  if(spawnTimer>200){ spawnObstacle(); spawnTimer=0; }

  for(const o of obstacles){
   o.x-=worldSpeed;
   if(
    player.x+player.r>o.x&&
    player.x-player.r<o.x+o.width&&
    (player.y-player.r<o.gapY||player.y+player.r>o.gapY+o.gap)
   ){
    if(mode!=="zen"){
     lives--;
     if(lives<=0) level=mode==="standard"?savedLevel:1;
    }
    alive=mode==="zen";
    playTone(140,0.3,"sawtooth",0.07);
   }
  }

  obstacles=obstacles.filter(o=>o.x+o.width>0);
  if(score>=levelTarget) nextLevel();
 }

 particles.forEach(p=>{
  ctx.globalAlpha=p.life/22;
  ctx.fillStyle=p.color;
  ctx.fillRect(p.x,p.y,2,2);
  p.x+=p.vx; p.y+=p.vy; p.life--;
 });
 ctx.globalAlpha=1;
 particles=particles.filter(p=>p.life>0);

 drawAstronaut();
 drawPlants();

 ctx.fillStyle="#222";
 obstacles.forEach(o=>{
  ctx.fillRect(o.x,0,o.width,o.gapY);
  ctx.fillRect(o.x,o.gapY+o.gap,o.width,canvas.height);
 });

 // UI
 ctx.fillStyle="#aaa"; ctx.font="16px monospace";
 ctx.fillText(`LEVEL ${level}`,20,24);
 ctx.fillRect(20,36,120,6);
 ctx.fillStyle="#0f0";
 ctx.fillRect(20,36,(score/levelTarget)*120,6);

 if(!started) drawModeSelect();
 requestAnimationFrame(update);
}
update();
</script>
</body>
</html>
